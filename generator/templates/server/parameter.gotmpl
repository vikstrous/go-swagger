{{ define "sliceparamvalidator"}}
{{ if .NeedsSize }}
{{ camelize .Name }}Size := int64(len({{ .ValueExpression }}))
{{ end }}
{{ if .MinItems }}
if err := validate.MinItems({{ .Path }}, "{{ .Location }}", {{ camelize .Name }}Size, {{ .MinItems }}); err != nil {
  return err
}
{{ end }}
{{ if .MaxItems }}
if err := validate.MaxItems({{ .Path }}, "{{ .Location }}", {{ camelize .Name }}Size, {{.MaxItems}}); err != nil {
  return err
}
{{ end }}
{{ if .UniqueItems }}
if err := validate.UniqueItems({{ .Path }}, "{{ .Location }}", {{ .ValueExpression }}); err != nil {
  return err
}
{{ end }}
{{ if .Enum }}
if err := validate.Enum({{ .Path }}, "{{ .Location }}", {{ .ValueExpression }}, {{ .Enum }}); err != nil {
  return err
}
{{ end }}
{{ end }}{{ define "propertyparamvalidator" }}
{{ if .IsPrimitive }}{{ template "primitivevalidator" . }}{{ end }}
{{ if .IsCustomFormatter }}{{ template "customformatparamvalidator" . }}{{ end }}
{{ if .IsArray }}{{ template "sliceparamvalidator" . }}{{ end }}
{{ end }}{{define "bindprimitiveparam" }}
{{ end }}{{define "sliceparambinder" }}
{{ if .Parent }}{{ .IndexVar }}c := swag.SplitByFormat({{ .Parent.IndexVar }}c[{{ .Parent.IndexVar }}], "{{ .CollectionFormat }}")
{{ else }}{{ .IndexVar }}c := raw{{ end }}
{{ .IndexVar }}sz := size
var {{ .IndexVar }}r {{ .GoType }}
{{ .IndexVar }}ValidateElement := func({{ .IndexVar }} int, {{ camelize .Child.Name }} {{ .Child.GoType }}) *errors.Validation {
  {{ template "propertyparamvalidator" .Child }}
  return nil
}

for {{ .IndexVar }} := 0; {{ .IndexVar }} < {{ .IndexVar }}sz; {{ .IndexVar }}++ {
  {{ if or .Child.IsCustomFormatter .Child.IsPrimitive }}{{ if .Child.Converter }}value, err := {{ .Child.Converter }}({{ .IndexVar }}c[{{ .IndexVar }}])
  if err != nil {
    return errors.InvalidType({{ .Child.Path }}, "{{ .Location }}", "{{ .Child.GoType }}", {{ .IndexVar }}c[{{ .IndexVar }}])
  }

  if err := {{ .IndexVar }}ValidateElement({{ .IndexVar }}, {{ .Child.ValueExpression }}); err != nil {
    return err
  }
  {{ .IndexVar }}r = append({{ .IndexVar }}r, value)
  {{else}}
    if err := {{ .IndexVar }}ValidateElement({{ .IndexVar }}, {{ .IndexVar }}c[{{ .IndexVar }}]); err != nil {
      return err
    }
  {{ .IndexVar }}r = append({{ .IndexVar }}r, {{ .IndexVar }}c[{{ .IndexVar }}]){{ end }}{{ else if .Child.IsArray }}
  {{ template "sliceparambinder" .Child }}
    if err := {{ .IndexVar }}ValidateElement({{ .IndexVar }}, {{ .Child.IndexVar }}r); err != nil {
      return err
    }
  {{ .IndexVar }}r = append({{ .IndexVar }}r, {{ .Child.IndexVar }}r){{ end }}
}
{{ end }}package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "net/http"
  "github.com/vikstrous/go-swagger/errors"
  "github.com/vikstrous/go-swagger/httpkit/validate"
  "github.com/vikstrous/go-swagger/httpkit"
  "github.com/vikstrous/go-swagger/swag"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// {{ pascalize .Name }}Params contains all the bound params for the {{ humanize .Name }} operation
// typically these are obtained from a http.Request
type {{ pascalize .Name }}Params struct {
  {{ range .Params }}{{ if .Description }}// {{ .Description }}{{ end }}
  {{ pascalize .Name }} {{.GoType}}
  {{ end}}
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
  var res []error
  {{ if .HasQueryParams }}qs := r.URL.Query()
  {{ else if .HasFormParams }}
  {{ end }}

  {{ range .Params }}
  {{ if not .IsArray }}{{ if .IsQueryParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(qs.Get({{ .Path }}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsPathParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(route.Params.Get({{ .Path }}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsHeaderParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(r.Header.Get({{ .Path }}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if .IsFormParam }}{{if .IsFileParam }}{{ camelize .Name }}, {{ camelize .Name }}Header, err := r.FormFile({{ .Path }})
  if err != nil {
    res = append(res, errors.New(400, "reading file \"{{ camelize .Name }}\" failed: %v", err))
  } else {
    {{ .ReceiverName }}.{{ pascalize .Name }} = httpkit.File{Data: {{ camelize .Name }}, Header: {{ camelize .Name }}Header}
  }
  {{ else }}if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(r.FormValue({{ .Path }}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{ end }}{{ end }}
  {{ else if .IsArray }}{{ if .IsQueryParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(swag.SplitByFormat(qs.Get({{ .Path }}), "{{ .CollectionFormat }}"), route.Formats); err != nil {
    res = append(res, err)
  }
  {{ else if and .IsFormParam }}if err := {{ .ReceiverName }}.bind{{ pascalize .Name }}(swag.SplitByFormat(r.FormValue({{ .Path }}), "{{ .CollectionFormat }}"), route.Formats); err != nil {
    res = append(res, err)
  }
  {{ end }}{{ end }}

  {{ if .IsBodyParam }}
  if err := route.Consumer.Consume(r.Body, &{{ .ReceiverName }}.{{ pascalize .Name }}); err != nil {
    res = append(res, errors.NewParseError("{{ camelize .Name }}", "{{ .Location }}", "", err))
  } else {
    {{ if .IsArray }}for _, {{ .IndexVar }}{{ .ReceiverName }} := range {{ .ReceiverName }}.{{ pascalize .Name }} {
      if err := {{ .IndexVar }}{{ .ReceiverName }}.Validate(route.Formats); err != nil {
        res = append(res, err)
        break
      }
    }
    {{ else }}if err := {{ .ReceiverName }}.{{ pascalize .Name }}.Validate(route.Formats); err != nil {
      res = append(res, err)
    }
    {{ end }}
  }

  {{ end }}
  {{ end }}
  if len(res) > 0 {
    return errors.CompositeValidationError(res...)
  }
  return nil
}

{{ $className := (pascalize .Name) }}
{{ range .Params }}
{{ if not .IsBodyParam }}
{{ if or .IsPrimitive .IsCustomFormatter }}
func ({{ .ReceiverName }} *{{ $className }}Params) bind{{ pascalize .Name }}(raw string, formats strfmt.Registry) error {
  {{ if and (not .IsPathParam) .Required }}if err := validate.RequiredString({{ .Path }}, "{{ .Location }}", raw); err != nil {
    return err
  }
  {{ end }}
  {{ if .Converter }}value, err := {{ if .Converter }}{{ .Converter }}({{ end }}raw)
  if err != nil {
    return errors.InvalidType({{ .Path }}, "{{ .Location }}", "{{ .GoType }}", raw)
  }
  {{ .ValueExpression }} = value
  {{ else if .IsCustomFormatter }}value, err := formats.Parse({{ printf "%q" .SwaggerFormat }}, raw)
  if err != nil {
    return errors.InvalidType({{ .Path }}, "{{ .Location }}", "{{ .GoType }}", raw)
  }
  {{ .ValueExpression }} = *(value.(*{{ .GoType }}))
  {{else}}{{ .ValueExpression }} = raw
  {{ end }}
  {{if .HasValidations }}if err := {{ .ReceiverName }}.validate{{ pascalize .Name }}(formats); err != nil {
    return err
  }
  {{ end }}
  return nil
}
{{else if .IsArray}}
func ({{ .ReceiverName }} *{{ $className }}Params) bind{{ pascalize .Name }}(raw []string, formats strfmt.Registry) error {
  size := len(raw)

  {{if .Required }}if size == 0 {
    return errors.Required({{ .Path }}, "{{ .Location }}")
  }
  {{ end }}

  {{ if .Default }}defValue := swag.SplitByFormat({{ .Default }}, "{{ .CollectionFormat }}")
  if size == 0 && len(defValue) > 0 {
    {{ .ValueExpression }} = defValue
  {{ else }}if size == 0 {
    return nil{{ end }}
  }
  {{ template "sliceparambinder" . }}
  {{ .ValueExpression }} = {{ .IndexVar }}r
  {{ if .HasSliceValidations }}if err := {{ .ReceiverName }}.validate{{ pascalize .Name }}(formats); err != nil {
    return err
  }
  {{ end }}

  return nil
}
{{ end }}
{{ if or .HasValidations .HasSliceValidations }}
func ({{ .ReceiverName }} *{{ $className }}Params) validate{{ pascalize .Name }}(formats strfmt.Registry) error {
  {{ template "propertyparamvalidator" . }}
  return nil
}
{{ end }}
{{ end }}
{{ end }}

{{ range .ExtraSchemas }}
/*
{{ template "docstring" . }}
swagger:model {{ .Name }}
*/
{{ template "schema" . }}
{{ end }}
